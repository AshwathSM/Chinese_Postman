package edu.neu.coe.info6205.final_project;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.Random;

public class GeneticAlgorithm {
//	final static Logger logger = Logger.getLogger(GeneticAlgorithm.class);
	private EdgeWeightedGraph G;
	private Population population;
	private int generations;
	
	
	public GeneticAlgorithm(EdgeWeightedGraph G) {
		this.G= G;
		
		generations =0;
	}	

	
	public void run()
	{
		initialize();
		System.out.println("generation: "+generations);
		System.out.println("initial population:");
		
		for(int i=0;i<population.members.size();i++)
			System.out.println(population.members.get(i).getGenes());
		System.out.println("best rank: "+ population.members.get(0).getFitness());
		
		int lastBest =Integer.MAX_VALUE;
		int consistentGenerations=0;
		
		
		while(true)
		{				
			evolve();
			
			generations++;
			
			System.out.println("generation: "+ generations);
			
			
			/*too big a list of solutions to display*/
//			for(int j=0;j<population.members.size();j++)
//				System.out.println(population.members.get(j).getGenes());
			System.out.println("best rank: "+ population.members.get(0).getFitness());
			
			/*printing only the best solution of each generation*/
			System.out.println("best solution of this generation: "+ population.members.get(0).getGenes());
			
			System.out.println("population count: "+ population.members.size() );
			
			/*break if the solution is not getting significantly better for 10 generations*/
			if(lastBest>population.members.get(0).getFitness()) {
				lastBest = population.members.get(0).getFitness();
				consistentGenerations=0;
			}
			else {
				consistentGenerations++;
			}
			if (consistentGenerations>20)
				break;			
			
		}
		System.out.println("optimum solution: shortest possible distance: "+ population.members.get(0).getFitness());
		System.out.println("solution is reached after "+generations +" generations");
		System.out.println("number of vertices: "+G.V() +" and number of odd vertices: "+population.members.get(0).getGenes().size());
		System.out.println("The best combination of nodes to retrace: " );
		
		
		for(int i =0;i<population.members.get(0).getGenes().size(); i++)
		{
			
			if(i%2 == 0)
				System.out.print("("+population.members.get(0).getGenes().get(i)+",");
			else
				System.out.print(population.members.get(0).getGenes().get(i)+")");
		}
		
	}
	
	/*generates initial population- Generation-0
	 * the number of individuals in the starting generation is taken as 4*/
	public void initialize()
	{		
		
		ArrayList<Integer> oddVertices = new ArrayList<Integer>();
		
		for(int i=0;i<G.V();i++)
		{
			int degree = EdgeWeightedGraph.degree(G, i);
			if((degree%2)!=0)
				oddVertices.add(i);
		}
		
		int sizeOfPopulation = 6;
		
		population = new Population();
		
		/*6 individuals will be created*/

	
		for(int loop=0;loop<sizeOfPopulation;loop++)
		{
			

			Individual adam = new Individual(G, oddVertices);
			population.addMember(adam);	
			
			Collections.shuffle(oddVertices);

			
		}
		
		population.calculateFitness();
		Collections.sort(population.members);
		
	}
	
	/*after every generation, unfit members are killed, crossBreeding is performed, mutation is performed*/
	private void evolve()
	{
		if(generations>0)
			cull();
		
		ArrayList<Individual> offsprings = new ArrayList<Individual>();	
		
		for(int i=0; i<population.members.size();i++)
		{
		
			ArrayList<Integer> genome = new ArrayList<>();
			for(int j=0;j< population.members.get(i).getGenes().size(); j++) {
				
				genome.add(population.members.get(i).getGenes().get(j));
			}
				
			Individual child = new Individual(G, genome);
			offsprings.add(child);
		}
		
		for(int i=0;i<offsprings.size()-1;i+=2)
		{
			crossBreed(offsprings.get(i), offsprings.get(i+1));
		}
		
		
		/*Select 2 Individuals generated by crossBreed randomly as mutants*/
		Random r = new Random();
		int select = r.nextInt(offsprings.size());	
		
		mutation(offsprings.get(select));
		
		select = r.nextInt(offsprings.size());	
		
		mutation(offsprings.get(select));
		
		for(int i=0;i<offsprings.size();i++)
		{
			population.members.add(offsprings.get(i));
		}
		
				
		population.calculateFitness();		
		Collections.sort(population.members);	
		
	}
	
	
	/*All individuals above the 100 ranks more are deemed as unfit and are killed
	 * also if the number of parents in a generation is more than 10, only the best 10 are retained*/
	private void cull()
	{		
		/*set rank cut-off as 100 more than the best rank*/
		int fitScore = population.members.get(0).getFitness();
		fitScore = fitScore+100;
		
		/*save 2nd best individuals for cross-over in case of bad cull cutoff selection*/		
		Individual secondFittest  = population.members.get(1);
		
		
		
		Iterator<Individual> iter = population.members.iterator();
		while(iter.hasNext())
		{
			Individual ind = iter.next();
			if(ind.getFitness()> fitScore)
			{
				/*remove any individual with 30% more rank value than the fittest*/ 
				iter.remove();
			}				
		}
		
		/*in case of culling of all the members except the best individual, add save second best to
		*continue the population*/
		if(population.members.size()<2)
		{
			population.members.add(secondFittest);
		}	
		
		/*in case of more than 10 solutions, save the best 10 and cull the rest
		*continue the population*/
		if(population.members.size()>20)
		{
			for(int iter1=population.members.size()-1; iter1>10;iter1--)
				population.members.remove(population.members.get(iter1));
		}	
		
		
	}
	
	/*changes the gene pool of the individual
	 * 1. A random even number is generated
	 * 2. The genes equal to this number are transformed to the offspring from the first parent
	 * 3. The rest of the genes are selected from the  second parent and the genome is repaired to 
	 *    to make the solution valid
	 * 4. One more offspring in created using the same method but swapping the parents' role  */
	public void crossBreed(Individual a, Individual b)
	{
		int geneSize = a.getGenes().size();
		Random rand = new Random();
		
		int randomNum = rand.nextInt(a.getGenes().size()/2);
		
		
		ArrayList<Integer> newGene = new ArrayList<>();
		ArrayList<Integer> newGene2 = new ArrayList<>();
		
		for(int i=0;i<2*randomNum;i++)
		{
			newGene.add(a.getGenes().get(i));
//			newGene2.add(b.getGenes().get(i));
		}

		
		for(int i=0; i<geneSize; i++)
		{
			newGene.add(b.getGenes().get(i));
//			newGene2.add(a.getGenes().get(i));
		}
		
		for(int i=geneSize-1;i>=2*randomNum;i--)
		{
//			newGene.add(a.getGenes().get(i));
			newGene2.add(b.getGenes().get(i));
		}

		
		for(int i=geneSize-1; i>=0; i--)
		{
//			newGene.add(b.getGenes().get(i));
			newGene2.add(a.getGenes().get(i));
		}
		
		/*Repair: remove duplicate genes*/
		newGene = new ArrayList<Integer>(new LinkedHashSet<Integer>(newGene));
		newGene2 = new ArrayList<Integer>(new LinkedHashSet<Integer>(newGene2));
		
		
		a.setGenes(newGene);
		b.setGenes(newGene2);		
	}
	
	
	/*mutation is means of evolution through asexual breeding
	 * this functions pairs the genes randomly with other in the gene of an individual*/
	public void mutation(Individual a)
	{
		
		Random rand = new Random();
		
		int randomNum = rand.nextInt(a.getGenes().size());
		
		ArrayList<Integer> newGene = new ArrayList<>();
	
		int geneSize = a.getGenes().size();
		for(int i=0;i<geneSize;i++)
		{
			newGene.add(a.getGenes().get(i));
			newGene.add(a.getGenes().get((i+randomNum)%geneSize));	
			
		}
		
		/*remove duplicate genes*/
		newGene = new ArrayList<Integer>(new LinkedHashSet<Integer>(newGene));
	
		a.setGenes(newGene);
		
	}
	

	


}
